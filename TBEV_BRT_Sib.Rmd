---
title: "TBEV_BRT_Sib"
output: html_document
date: "2024-04-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_knit$set(root.dir="BRT_padiweb/")
```



```{r libraries, message = FALSE, warning=FALSE, echo = TRUE}
library(blockCV)
library(dismo)
library(exactextractr)
library(gbm)
library(geosphere)
library(lubridate)
library(maptools)
library(ncdf4)
library(ncf)
library(raster)
library(RColorBrewer)
library(rgdal)
library(rgeos)
library(sf)
library(sp)
library(dplyr)
library(tidyr)
library(ggplot2);library(ggmap);
library(RColorBrewer)
source('/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Scripts/functions.R')

```







#### Loading data 


```{r load_data,  message = FALSE, warning=FALSE, echo = TRUE}


TBEV = readOGR("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Shapefiles/GADM.all.shp") # modified NUT3 shapefile


bbox_TBEV <- bbox(TBEV)
extent <- extent(bbox_TBEV[1], bbox_TBEV[3], bbox_TBEV[2], bbox_TBEV[4]) # Remplacez par les valeurs souhaitées
#TBEV <- crop(TBEV, extent)



TBEV@data <- TBEV@data %>% 
  rename(year_unknown = year_unkno)

#permet de ne plus avoir le petit bout de Russie à droite déplacé sur la carte
new_crs <- "+proj=longlat +datum=WGS84 +lon_0=140 +no_defs"
TBEV.projection <- spTransform(TBEV, CRS(new_crs))
contour = unionSpatialPolygons(TBEV.projection, rep(1,length(TBEV.projection)))

```


##Data creation for BRT
```{r}

TBEV.data <- TBEV@data

#One line per year
TBEV.data <- TBEV.data %>%
  gather(key = "year_type", value = "year", year_Eur, year_Sib, year_FE,year_unknown) %>%
  separate_rows(year, sep = ", ") %>%
  filter(year != "NA") %>%
  mutate(year = as.integer(year))

#Delete all NA's
TBEV.data <- TBEV.data %>% filter(year != "NA")

#ignore years after 2019
TBEV.data <- TBEV.data %>% filter(year < 2020)

lst <- TBEV.data[, c( "ID","year","year_type")]

nb_total_dupliques = sum(duplicated(lst) | duplicated(lst, fromLast = TRUE))

TBEV.pres = subset(TBEV, ID %in% TBEV.data$ID)

TBEV.pres@data$folds_Eur = NA
TBEV.pres@data$folds_Sib = NA
TBEV.pres@data$folds_FE = NA


```


#map of the presence of TBEV-Sib
```{r}
# Function to plot a single map
png("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Ecological_suitability_maps/Sib_pres.png", width = 3200, height = 1600, res = 200)  # 2400x2400 pixels at 300 PPI
# Set up plotting layout
par(mfrow = c(1, 1),  #  rows, columns layout
    oma = c(0, 0, 0, 0),  # Outer margins
    mar = c(0, 0, 0, 0) + 0.1,  # Reduce plot margins to fit better
    mgp = c(0, 0, 0),  # Margin line for title, axis labels, and axis line
    cex = 0.8)  # Reduce the size of text to fit better
presence_data_Sib <- TBEV.projection[TBEV.projection$Sib == 1, ]

# Choose the Dark2 color palette and select the 5th color
dark2_palette <- brewer.pal(n = 8, name = "Dark2")  # Dark2 has 8 colors
selected_color <- dark2_palette[3]

# Adjust the color for transparency
presence_fill <- adjustcolor(selected_color, alpha.f = 0.5)

# Plot the base contour with a subtle border color from the palette
plot(contour, lwd = 0.2, border = "gray40" , col = NA)

# Overlay the TBEV projection with a very light and less visible background color from the palette
plot(TBEV.projection, col = "gray90", border = "gray80", lwd = 0.1, add = TRUE)

# Highlight the presence data with the selected color and the same border color but more transparent
plot(presence_data_Sib, col = presence_fill, border = NA, lwd = 0.1, add = TRUE)

# Add legend for presence data with specific coordinates and adjusted size
# Use inset to position the legend within the plotting area
# Use inset to position the legend within the plotting area
legend("bottomright", legend = "TBEV-Sib occurence detected",
       pch = 15, col = presence_fill, pt.cex = 6,cex= 1.5 ,x.intersp = 2, bty = "n", xpd = TRUE, inset = c(0.05, 0.9))
```
#### Loading and plotting climatic covariate data

Here we will only consider temperature, precipitation and relative huimidity data. The climate data is available at The Inter-Sectoral Impact Model Intercomparison Project (https://www.isimip.org/).



```{r}

data_Sib = as.data.frame(matrix(NA,nrow=nrow(TBEV.data), ncol =24))
colnames(data_Sib) = c("longitude","latitude","ID","year","response","temperature_winter","temperature_spring","temperature_summer","temperature_autumn","precipitation_winter","precipitation_spring","precipitation_summer","precipitation_autumn","relative_humidity_winter","relative_humidity_spring","relative_humidity_summer","relative_humidity_autumn","croplands","pastures","urbanAreas","primaryForest","secondaryForest","rangelands","population")


data_all = data_all = as.data.frame(matrix(NA,nrow=nrow(TBEV@data), ncol =24))
colnames(data_all) = c("longitude","latitude","ID","year","response","temperature_winter","temperature_spring","temperature_summer","temperature_autumn","precipitation_winter","precipitation_spring","precipitation_summer","precipitation_autumn","relative_humidity_winter","relative_humidity_spring","relative_humidity_summer","relative_humidity_autumn","croplands","pastures","urbanAreas","primaryForest","secondaryForest","rangelands","population") 


```

## Landuse and population data loading 
```{r env_data,  message = FALSE, warning=FALSE, echo = TRUE}

# Load landuse data
croplands = brick("/Users/loicgonzalez/Desktop/output/landuse/landuse-totals_histsoc_annual_1901_2021.nc",varname = "cropland_total")
pastures = brick("/Users/loicgonzalez/Desktop/output/landuse/landuse-totals_histsoc_annual_1901_2021.nc",varname = "pastures")
urbanAreas = brick("/Users/loicgonzalez/Desktop/output/landuse/landuse-urbanareas_histsoc_annual_1901_2021.nc")
primaryForest = brick("/Users/loicgonzalez/Desktop/output/landuse/LUH2_GCB2019/LUH2_GCB2019_primf_remapcon_1901_2019.nc")
secondaryForest = brick("/Users/loicgonzalez/Desktop/output/landuse/LUH2_GCB2019/LUH2_GCB2019_secdf_remapcon_1901_2019.nc")
rangelands = brick("/Users/loicgonzalez/Desktop/output/landuse/LUH2_GCB2019/LUH2_GCB2019_range_remapcon_1901_2019.nc")

# Load population data
population = brick("/Users/loicgonzalez/Desktop/output/population/ISIMIP3a/population_histsoc_30arcmin_annual_1850_2021.nc")




```

#### Building a dataframe considering disease and covariate data
#make data for every subtype

```{r env_data,  message = FALSE, warning=FALSE, echo = TRUE}
# Load climatic data
temperature = brick("/Users/loicgonzalez/Desktop/output/ISIMIP3a/obsclim/GSWP3-W5E5/gswp3-w5e5_obsclim_tas_1901_2019_monmean.nc")
precipitation = brick("/Users/loicgonzalez/Desktop/output/ISIMIP3a/obsclim/GSWP3-W5E5/gswp3-w5e5_obsclim_pr_1901_2019_monmean.nc")
humidity = brick("/Users/loicgonzalez/Desktop/output/ISIMIP3a/obsclim/GSWP3-W5E5/gswp3-w5e5_obsclim_hurs_1901_2019_monmean.nc")



for(i in 1:nrow(TBEV.data)){
  year = TBEV.data$year[i]#collection year
  id = TBEV.data$ID[i]#ID of the TBEV
  resp = TBEV.data$Sib[i]#response

  year1 = year - 1900
  croplands_temp = croplands[[year1]]; pastures_temp = pastures[[year1]]
  urbanAreas_temp = urbanAreas[[year1]]; primaryForest_temp = primaryForest[[year1]]
  secondaryForest_temp = secondaryForest[[year1]]; rangelands_temp = rangelands[[year1]]

  year2 = year - 1849
  pLog = population[[year2]]; pLog[] = log10(pLog[]+1)
  population_temp = pLog

  month_start = if(year == 1901) 1 else 12 * (year - 1901) ;month_end = if(year == 1901) 11  else month_start + 11
  temperature_temp = temperature[[month_start:month_end]];  precipitation_temp = precipitation[[month_start:month_end]];     relhumidity_temp = humidity[[month_start:month_end]]

  j11 = 1:3; j12 = 4:6; j13 = 7:9; j14=10:12
  temp_winter= temperature_temp[[j11]];temp_spring = temperature_temp[[j12]];temp_summer= temperature_temp[[j13]];temp_autumn = temperature_temp[[j14]];
  precp_winter= precipitation_temp[[j11]];precp_spring = precipitation_temp[[j12]];precp_summer= precipitation_temp[[j13]];precp_autumn = precipitation_temp[[j14]];
  rel_winter= relhumidity_temp[[j11]];rel_spring = relhumidity_temp[[j12]];rel_summer= relhumidity_temp[[j13]];rel_autumn = relhumidity_temp[[j14]]

  data_Sib[i,"temperature_winter"] = exact_extract(mean(temp_winter),TBEV[(which(TBEV@data$ID == id)),],fun="mean")-273.15 # conversion to Celsius degrees
  data_Sib[i,"temperature_spring"] = exact_extract(mean(temp_spring),TBEV[(which(TBEV@data$ID == id)),],fun="mean")-273.15 # conversion to Celsius degrees
  data_Sib[i,"temperature_summer"] = exact_extract(mean(temp_summer),TBEV[(which(TBEV@data$ID == id)),],fun="mean")-273.15 # conversion to Celsius degrees
  data_Sib[i,"temperature_autumn"] = exact_extract(mean(temp_autumn),TBEV[(which(TBEV@data$ID == id)),],fun="mean")-273.15 # conversion to Celsius degrees
  
  data_Sib[i,"precipitation_winter"] = exact_extract(mean(precp_winter),TBEV[(which(TBEV@data$ID == id)),],fun="mean")*60*60*24 # conversion to kg/m2/day
  data_Sib[i,"precipitation_spring"] = exact_extract(mean(precp_spring),TBEV[(which(TBEV@data$ID == id)),],fun="mean")*60*60*24 # conversion to kg/m2/day
  data_Sib[i,"precipitation_summer"] = exact_extract(mean(precp_summer),TBEV[(which(TBEV@data$ID == id)),],fun="mean")*60*60*24 # conversion to kg/m2/day
  data_Sib[i,"precipitation_autumn"] = exact_extract(mean(precp_autumn),TBEV[(which(TBEV@data$ID == id)),],fun="mean")*60*60*24 # conversion to kg/m2/day
  
  data_Sib[i,"relative_humidity_winter"] = exact_extract(mean(rel_winter),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_Sib[i,"relative_humidity_spring"] = exact_extract(mean(rel_spring),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_Sib[i,"relative_humidity_summer"] = exact_extract(mean(rel_summer),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_Sib[i,"relative_humidity_autumn"] = exact_extract(mean(rel_autumn),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  
  data_Sib[i,"croplands"] = exact_extract(mean(croplands_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_Sib[i,"pastures"] = exact_extract(mean(pastures_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_Sib[i,"urbanAreas"] = exact_extract(mean(urbanAreas_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_Sib[i,"primaryForest"] = exact_extract(mean(primaryForest_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_Sib[i,"secondaryForest"] = exact_extract(mean(secondaryForest_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_Sib[i,"rangelands"] = exact_extract(mean(rangelands_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  
  data_Sib[i,"population"] = exact_extract(mean(pLog),TBEV[(which(TBEV@data$ID == id)),],fun="sum")
  
  data_Sib[i,"longitude"] = coordinates(TBEV[(which(TBEV@data$ID == id)),])[,1]
  data_Sib[i,"latitude"] = coordinates(TBEV[(which(TBEV@data$ID == id)),])[,2]
  data_Sib[i,"ID"] = id
  data_Sib[i,"year"] = year
  data_Sib[i,"response"] = resp
}



TBEV.all = TBEV@data

for(i in 1:nrow(TBEV@data)){
  year = 2019#collection year
  id = TBEV@data$ID[i]#ID of the TBEV

  year1 = year - 1900
  croplands_temp = croplands[[year1]]; pastures_temp = pastures[[year1]]
  urbanAreas_temp = urbanAreas[[year1]]; primaryForest_temp = primaryForest[[year1]]
  secondaryForest_temp = secondaryForest[[year1]]; rangelands_temp = rangelands[[year1]]

  year2 = year - 1849
  pLog = population[[year2]]; pLog[] = log10(pLog[]+1)
  population_temp = pLog

  month_start = if(year == 1901) 1 else 12 * (year - 1901) ;month_end = if(year == 1901) 11  else month_start + 11
  temperature_temp = temperature[[month_start:month_end]];  precipitation_temp = precipitation[[month_start:month_end]];     relhumidity_temp = humidity[[month_start:month_end]]

  j11 = 1:3; j12 = 4:6; j13 = 7:9; j14=10:12
  temp_winter= temperature_temp[[j11]];temp_spring = temperature_temp[[j12]];temp_summer= temperature_temp[[j13]];temp_autumn = temperature_temp[[j14]];
  precp_winter= precipitation_temp[[j11]];precp_spring = precipitation_temp[[j12]];precp_summer= precipitation_temp[[j13]];precp_autumn = precipitation_temp[[j14]];
  rel_winter= relhumidity_temp[[j11]];rel_spring = relhumidity_temp[[j12]];rel_summer= relhumidity_temp[[j13]];rel_autumn = relhumidity_temp[[j14]]

  data_all[i,"temperature_winter"] = exact_extract(mean(temp_winter),TBEV[(which(TBEV@data$ID == id)),],fun="mean")-273.15 # conversion to Celsius degrees
  data_all[i,"temperature_spring"] = exact_extract(mean(temp_spring),TBEV[(which(TBEV@data$ID == id)),],fun="mean")-273.15 # conversion to Celsius degrees
  data_all[i,"temperature_summer"] = exact_extract(mean(temp_summer),TBEV[(which(TBEV@data$ID == id)),],fun="mean")-273.15 # conversion to Celsius degrees
  data_all[i,"temperature_autumn"] = exact_extract(mean(temp_autumn),TBEV[(which(TBEV@data$ID == id)),],fun="mean")-273.15 # conversion to Celsius degrees
  
  data_all[i,"precipitation_winter"] = exact_extract(mean(precp_winter),TBEV[(which(TBEV@data$ID == id)),],fun="mean")*60*60*24 # conversion to kg/m2/day
  data_all[i,"precipitation_spring"] = exact_extract(mean(precp_spring),TBEV[(which(TBEV@data$ID == id)),],fun="mean")*60*60*24 # conversion to kg/m2/day
  data_all[i,"precipitation_summer"] = exact_extract(mean(precp_summer),TBEV[(which(TBEV@data$ID == id)),],fun="mean")*60*60*24 # conversion to kg/m2/day
  data_all[i,"precipitation_autumn"] = exact_extract(mean(precp_autumn),TBEV[(which(TBEV@data$ID == id)),],fun="mean")*60*60*24 # conversion to kg/m2/day
  
  data_all[i,"relative_humidity_winter"] = exact_extract(mean(rel_winter),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_all[i,"relative_humidity_spring"] = exact_extract(mean(rel_spring),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_all[i,"relative_humidity_summer"] = exact_extract(mean(rel_summer),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_all[i,"relative_humidity_autumn"] = exact_extract(mean(rel_autumn),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  
  data_all[i,"croplands"] = exact_extract(mean(croplands_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_all[i,"pastures"] = exact_extract(mean(pastures_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_all[i,"urbanAreas"] = exact_extract(mean(urbanAreas_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_all[i,"primaryForest"] = exact_extract(mean(primaryForest_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_all[i,"secondaryForest"] = exact_extract(mean(secondaryForest_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  data_all[i,"rangelands"] = exact_extract(mean(rangelands_temp),TBEV[(which(TBEV@data$ID == id)),],fun="mean")
  
  data_all[i,"population"] = exact_extract(mean(pLog),TBEV[(which(TBEV@data$ID == id)),],fun="sum")
  
  data_all[i,"longitude"] = coordinates(TBEV[(which(TBEV@data$ID == id)),])[,1]
  data_all[i,"latitude"] = coordinates(TBEV[(which(TBEV@data$ID == id)),])[,2]
  data_all[i,"ID"] = id
  data_all[i,"year"] = year

}

newdata_all = data_all[,c(6:24)]

```


#### Spatial cross-validation: Block method

This method requires a distance to create the blocks, this distance should be based on the spatial-autocorrelation of the data, thus we plot the correlogram and based on where it drops to 0, we set out parameter. 

# -------------------------------------------------------------------------------
#  ____    ___    ____  
# / ___|  |_ _|  | __ ) 
# \___ \   | |   |  _ \ 
#  ___) |  | |   | |_) |
# |____/  |___|  |____/ 
#
# -------------------------------------------------------------------------------

```{r load_brt_correlogram, message = FALSE, warning=FALSE, echo = TRUE}
#Sib
correlogram = ncf::correlog(data_Sib[,"longitude"], data_Sib[,"latitude"], data_Sib[,"response"], na.rm=T, increment=10, resamp=0, latlon=T)
dev.new(width=4.5, height=3); par(mar=c(2.2,2.2,1.5,1.5))
plot(correlogram$mean.of.class[-1], correlogram$correlation[-1], ann=F, axes=F, lwd=0.2, cex=0.5, col=NA, ylim=c(-0.4,1.0), xlim=c(0,5000))
abline(h=0, lwd=0.5, col="red", lty=2)
points(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, cex=0.35, col="gray30")
lines(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, col="gray30")
axis(side=1, pos=-0.4, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0,0,0), at=seq(0,9000,1000))
axis(side=2, pos=0, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0,0.18,0), at=seq(-0.4,1,0.2))
title(xlab="distance (km)", cex.lab=0.7, mgp=c(0.3,0,0), col.lab="gray30")
title(ylab="correlation", cex.lab=0.7, mgp=c(0.4,0,0), col.lab="gray30")
```




#### Setting the parameters for running the BRT models

```{r brt, message = FALSE, warning=FALSE, echo = TRUE}

newdata_Sib = data_Sib[,c(6:24)]
data_Sib = na.omit(data_Sib)

n.folds = 5
theRanges_Sib = c(2000,2000)*1000 # distance has to be in in meters

gbm.x = 6:24
gbm.y = 5
offset = NULL
tree.complexity = 5 # "tc" = number of nodes in the trees
learning.rate = 0.001 # "lr" = contribution of each tree to the growing model
bag.fraction = 0.80 # proportion of data used to train a given tree
site.weights_Sib = rep(1, dim(data_Sib)[1])
var.monotone = rep(0, length(gbm.x))
n.folds = 5
prev.stratify = TRUE
family = "bernoulli"
n.trees = 100 # initial number of trees
step.size = 10 # interval at which the predictive deviance is computed and logged
# (at each interval, the folds are successively used as test data set
# and the remaining folds as training data sets to compute the deviance)
max.trees = 10000 # maximum number of trees that will be considered
tolerance.method = "auto"
tolerance = 0.001
plot.main = TRUE
plot.folds = FALSE
verbose = FALSE
silent = FALSE
keep.fold.models = FALSE
keep.fold.vector = FALSE
keep.fold.fit = FALSE
showingFoldsPlot = FALSE


```





### 100 BRTs
```{r include=FALSE}

brt_model_outputs_Sib <- list()
auc_values_Sib <- numeric(100)

for (i in 1:100) {
  repeat {
    folds_with_similar_sizes <- FALSE
    while (!folds_with_similar_sizes) {
      spdf_Sib = SpatialPointsDataFrame(data_Sib[c("longitude", "latitude")], data_Sib, proj4string = crs(TBEV))
      myblocks_Sib = cv_spatial(spdf_Sib, column = "response", k = n.folds, size = theRanges_Sib, selection = "random", progress = FALSE)
      
      fold.vector_Sib = myblocks_Sib$folds_ids
      fold.vector_presences_Sib = fold.vector_Sib[which(data_Sib[, 5] == 1)]
      counts = hist(fold.vector_presences_Sib, plot = FALSE)$counts
      props = counts[which(counts > 0)] / sum(counts)
      print(round(props, 2))
      if (min(props) > 0.05) folds_with_similar_sizes <- TRUE
    }
    
    brt_model_Sib = gbm.step(data_Sib, gbm.x, gbm.y, offset, fold.vector_Sib, tree.complexity, learning.rate, bag.fraction, site.weights_Sib,
                             var.monotone, n.folds, prev.stratify, family, n.trees, step.size, max.trees, tolerance.method, tolerance, plot.main, plot.folds,
                             verbose, silent, keep.fold.models, keep.fold.vector, keep.fold.fit)
    
    if (is.null(brt_model_Sib)) {
      # Si le modèle est NULL, on recommence la boucle 'repeat' sans incrémenter 'i'
      cat("Le modèle est NULL, recommencement de l'itération.\n")
    } else {
      # Sortie de la boucle 'repeat' si le modèle n'est pas NULL
      break
    }
  }
  
  brt_model_outputs_Sib[[i]] <- brt_model_Sib
  auc_values_Sib[i] <- brt_model_Sib$cv.statistics$discrimination.mean
}

# Calculate 95% confidence interval
ci_AUC_Sib <- t.test(auc_values_Sib)$conf.int

save.image(file = "/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Data_BRT_Sib.RData")



```

### Relative influence of each environmental factor


```{r include=FALSE}
### SCRIPT for getting the relative influence of each environmental factor
## inputs: dataframe used for brt, brt_model (brt_model_outputs_Sib3)
# 1. create an empty matrix to fill with covariates
envVariableNames = names(newdata_Sib)
#Environmental variables legends for the plot + units
envVariableNames_legend <- list("Air temperature winter (°C)","Air temperature spring (°C)",
                                "Air temperature summer (°C)","Air temperature autumn (°C)",
                                "Precipitation winter (kg/m2/day)","Precipitation spring (kg/m2/day)",
                                "Precipitation summer (kg/m2/day)","Precipitation autumn (kg/m2/day)",
                                "Relative humidity winter (%)","Relative humidity spring (%)",
                                "Relative humidity summer (%)","Relative humidity autumn (%)",
                                "Croplands","Pastures","Urban areas","Primary forest areas",
                                "Secondary forest areas","Rangelands",
                                expression(frac(log[10], km^2))
                               )
relativeInfluences_Sib = matrix(0, nrow=length(envVariableNames), ncol=length(brt_model_outputs_Sib))
row.names(relativeInfluences_Sib) = envVariableNames
for (i in 1:100) {
  for (k in 1:length(envVariableNames))
  {
    relativeInfluences_Sib[k,i] = summary(brt_model_outputs_Sib[[i]])[gsub("-","\\.",envVariableNames)[k],"rel.inf"]
  }
}

relativeInfluences_Sib_mean <- matrix(rowMeans(relativeInfluences_Sib), nrow=length(envVariableNames), ncol=1)
row.names(relativeInfluences_Sib_mean) = envVariableNames

ci_lower_Sib <- c()
ci_upper_Sib <- c()
for (i in 1:length(envVariableNames)) {
  # Calculate 95% confidence interval
  ci <- t.test(relativeInfluences_Sib[i, ])$conf.int
  # Append results to lists
  ci_lower_Sib <- c(ci_lower_Sib, ci[1])
  ci_upper_Sib <- c(ci_upper_Sib, ci[2])
}

ci_envVariableNames_Sib <- data.frame(envVariableNames, round(ci_lower_Sib,2), round(ci_upper_Sib,2))
mean_relativeInfluences_Sib <- data.frame(round(relativeInfluences_Sib_mean,2))


#save it
write.table(round(relativeInfluences_Sib,1),paste0("Relative_influences_Sib.csv"), quote=F, sep=",")

# 2. plot presence curves
data_curv_Sib = data_Sib[which(data_Sib[,"response"]==1),] #assuming presence is in column "presence"
envVariableValues = matrix(nrow=3, ncol=length(envVariableNames))
row.names(envVariableValues) = c("median","minV","maxV")
colnames(envVariableValues) = envVariableNames

for (j in 1:length(envVariableNames))
{
  minV = min(data_curv_Sib[,envVariableNames[j]], na.rm=T)
  maxV = max(data_curv_Sib[,envVariableNames[j]], na.rm=T)
  medianV = median(data_curv_Sib[,envVariableNames[j]], na.rm=T)
  envVariableValues[,j] = rbind(medianV, minV, maxV)
}


envVariableValues_list = envVariableValues

layout_matrix <- matrix(c(1, 1, 1, 1,
                          2, 3, 4, 5,
                          6, 7, 8, 9,
                          10, 11, 12, 13,
                          14, 15, 16, 17,
                          18, 19, 20, 21), byrow = TRUE, nrow = 6)
```


```{r include=FALSE}
## prepare for plot (i used 5 rows, 4 columns, for 20 covariates)
png("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/100BRT_RI_parameters_Sib.png", width=2400, height=2400, res=300)
# Application de la matrice de layout
layout(layout_matrix, heights = c(0.5, 4, 4, 4, 4, 4))

# Titre général
par(mar=c(0, 0, 1, 0))  # Réduire la marge supérieure
plot(0, 0, type="n", axes=FALSE, xlab="", ylab="", main="")

# Réinitialisation des paramètres par défaut pour les graphiques
par(mar=c(4, 4, 2, 2))
for (i in 1:length(envVariableNames))
{
  predictions_list = list(); dfs = list()
  valuesInterval = 0.1; valuesInterval = (envVariableValues_list["maxV",i]-envVariableValues_list["minV",i])/100
  df = data.frame(matrix(nrow=length(seq(envVariableValues_list["minV",i],envVariableValues_list["maxV",i],valuesInterval)),ncol=length(envVariableNames)))
  colnames(df) = envVariableNames
  
  for (k in 1:length(envVariableNames))
  {
    valuesInterval = 0.1; valuesInterval = (envVariableValues_list["maxV",k]-envVariableValues_list["minV",k])/100
    if (i == k) df[,envVariableNames[k]] = seq(envVariableValues_list["minV",k],envVariableValues_list["maxV",k],valuesInterval)
    if (i != k) df[,envVariableNames[k]] = rep(envVariableValues_list["median",k],dim(df)[1])
  }
  dfs = df; predictions = list()
  
  brt_model_outputs_Sib = brt_model_outputs_Sib
  
  for (j in 1:length(brt_model_outputs_Sib))
  {
    n.trees = brt_model_outputs_Sib[j]$gbm.call$best.trees; type = "response"; single.tree = FALSE
    prediction = predict.gbm(brt_model_outputs_Sib[[j]], newdata=df, n.trees, type, single.tree)
    if ((j == 1))
    {
      minX = min(df[,envVariableNames[i]]); maxX = max(df[,envVariableNames[i]])
      minY = min(prediction); maxY = max(prediction)
    }	else	{
      if (minX > min(df[,envVariableNames[i]])) minX = min(df[,envVariableNames[i]])
      if (maxX < max(df[,envVariableNames[i]])) maxX = max(df[,envVariableNames[i]])
      if (minY > min(prediction)) minY = min(prediction)
      if (maxY < max(prediction)) maxY = max(prediction)
    }
    
    predictions[[j]] = prediction
  }
  predictions_list = predictions
  
  cols = "red"
    for (l in 1:length(brt_model_outputs_Sib))
    {
      if (( l == 1))
      {
        plot(dfs[,envVariableNames[i]],predictions_list[[l]],col=cols,ann=F,axes=F,lwd=0.2,type="l",xlim=c(minX,maxX),ylim=c(minY,maxY))
        mtext(paste0(round(relativeInfluences_Sib_mean[i, 1], 1), "%"), side = 3, line = 0.5, cex = 0.8, col = "black")

      }	else	{
        lines(dfs[,envVariableNames[i]],predictions_list[[l]],col=cols,lwd=0.2)
      } 
      
    }
    if (is.expression(envVariableNames_legend[[i]])) {
      # It's an expression, enhance it with additional text using bquote
       x_label <- bquote("Human pop. density " ~(log[10]/km^2))
   } else {
       # It's regular text, construct label normally
       x_label <- paste0(envVariableNames_legend[i])
   }
  
  # plot instructions
  axis(side=1, lwd.tick=0.2, cex.axis=0.7, lwd=0, tck=-0.030, col.axis="gray30", mgp=c(0,0.07,0))
  axis(side=2, lwd.tick=0.2, cex.axis=0.7, lwd=0, tck=-0.030, col.axis="gray30", mgp=c(0,0.2,0))
  title(ylab="predicted values", cex.lab=0.9, mgp=c(1.3,0,0), col.lab="gray30")
  title(xlab=x_label, cex.lab=0.9, mgp=c(0.9,0,0), col.lab="gray30")
  box(lwd=0.2, col="gray30")
}


dev.off()


```


#### 4. Create an ecological suitability map based on the best model



```{r}
nberOfReplicates = 100 #you have 100 BRT models
prediction_present_Sib = matrix(0, nrow=length(pop), ncol=nberOfReplicates)

for(i in 1:nberOfReplicates){
    n.trees = brt_model_outputs_Sib[[i]]$gbm.call$best.trees; type = "response"; single.tree = FALSE
    object = brt_model_outputs_Sib[[i]]; prediction = predict.gbm(object, newdata_all, n.trees, type, single.tree)
    prediction_present_Sib[,i] = prediction
}

prediction_present_Sib_mean <- rowMeans(prediction_present_Sib)

```

```{r results1, message = FALSE, warning=FALSE, echo = TRUE}

#Sib
png("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Ecological_suitability_maps/ecological_suitability_Sib_present.png", width = 3200, height = 1600, res = 200)  # 2400x2400 pixels at 300 PPI
# Set up plotting layout
par(mfrow = c(1, 1),  #  rows, columns layout
    oma = c(0, 0, 0, 0),  # Outer margins
    mar = c(0, 0, 0, 0) + 0.1,  # Reduce plot margins to fit better
    mgp = c(0, 0, 0),  # Margin line for title, axis labels, and axis line
    cex = 0.8)  # Reduce the size of text to fit better


# Function to plot a single map
plot_map <- function(index, key, data) {
  cols <- colourScale[round(((data - global_min) / (global_max - global_min)) * 110) + 1]
  plot(contour, lwd = 0.2, border = "gray30", col = NA)  # Base contour
  plot(TBEV.projection, col = cols, border = NA, lwd = 0.1, add = TRUE)  # Add the data
}

plot_map(i, key, prediction_present_Sib_mean)
visible_positions <- c(0.2,0.4,0.6,0.8)  # Specify the positions of the labels

rast <- raster(as.matrix(c(global_min, global_max)))
plot(rast, legend.only = TRUE, add = TRUE, col = colourScale, 
     legend.width = 0.5, legend.shrink = 2, 
     smallplot = c(0.9, 0.905, 0.4, 0.55), adj = 3, 
     axis.args = list(
       at = visible_positions, # Spécifiez les positions des étiquettes
       labels = round(visible_positions, 2), # Spécifiez les étiquettes correspondantes
       cex.axis = 1.5,      # Ajustez cette valeur pour la taille des chiffres
       lwd = 1,             # Largeur des lignes de l'axe
       col = "gray30", 
       lwd.tick = 1,      # Largeur des petits traits des graduations
       col.tick = "gray30", 
       tck = -1,          # Longueur des  petits traits des graduations
       col.axis = "gray30", 
       line = 0, 
       mgp = c(0, 1, 0)  # Position des axes et des étiquettes
     ), 
     alpha = 1, side = 3)
  
  
  
  


```

#Sorensen index



```{r}
TBEV@data$pred_Sib = prediction_present_Sib_mean

TBEV_sorensen_Sib <- TBEV@data

#One line per year
TBEV_sorensen_Sib <- TBEV_sorensen_Sib %>%
  filter(sum > 0) 

#Delete all NA's
TBEV_sorensen_Sib <- TBEV_sorensen_Sib %>% filter(year != "NA")

#ignore years after 2019
TBEV_sorensen_Sib <- TBEV_sorensen_Sib %>% filter(year < 2020)


data_sorensen_Sib = data.frame("response" = TBEV_sorensen_Sib$Sib, "ecological suitability" = TBEV_sorensen_Sib$pred_Sib) #column 1: presence/absence, column 2: ecological suitability
thres = rep(1:100,each = 1)*0.01
data_comp_Sib = as.data.frame(matrix(0,nrow = length(thres), ncol = 6))
colnames(data_comp_Sib) = c("TP","FP","FN","TN","SI","threshold")
data_comp_Sib[,"threshold"] = thres
for(i in 1:length(thres)){
    for(j in 1: nrow(data_sorensen_Sib)){
      # True positive
      if(data_sorensen_Sib[j,1] == 1 && data_sorensen_Sib[j,2] >= thres[i]){
        data_comp_Sib[i,"TP"] = data_comp_Sib[i,"TP"] + 1
      }
      # False negative
      if(data_sorensen_Sib[j,1] == 1 && data_sorensen_Sib[j,2] < thres[i]){
        data_comp_Sib[i,"FN"] = data_comp_Sib[i,"FN"] + 1
      }
      if(data_sorensen_Sib[j,1] == 0 && data_sorensen_Sib[j,2] >= thres[i]){
        data_comp_Sib[i,"FP"] = data_comp_Sib[i,"FP"] + 1
      }
      if(data_sorensen_Sib[j,1] == 0 && data_sorensen_Sib[j,2] < thres[i]){
        data_comp_Sib[i,"TN"] = data_comp_Sib[i,"TN"] + 1
      }
    }  
}

x = sum(data_sorensen_Sib$response == 1)/sum(data_sorensen_Sib$response == 0)*(1 -sum(data_sorensen_Sib$response == 1)/nrow(data_sorensen_Sib))/(sum(data_sorensen_Sib$response == 1)/nrow(data_sorensen_Sib))

data_comp_Sib[,"SI"] = (2*(data_comp_Sib[,"TP"]))/((2*data_comp_Sib[,"TP"])+(x*data_comp_Sib[,"FP"])+data_comp_Sib[,"FN"])  
save.image(file = "/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Data_BRT_Sib.RData")

```





### PAST
```{r include=FALSE}

data_past_Sib <- list()
prediction_past_Sib <- list()
year_intervals = c("1901_1919","1920_1939","1940_1959","1960_1979","1980_1999","2000_2019") 
folder_model_past = c("counterclim","obsclim")
for (i in 1:length(folder_model_past)){
  for (j in 1:length(year_intervals)){
    
  tempmm = brick(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3a_past/",folder_model_past[i],"/tas_day_",folder_model_past[i],"_historical_gswp3-w5e5_",year_intervals[j],"_ymonmean.nc"))
  tempmm_winter = mean(tempmm[[12]],tempmm[[1]],tempmm[[2]])-273.15 # winter months: dec,jan,feb
  tempmm_spring = mean(tempmm[[3]],tempmm[[4]],tempmm[[5]])-273.15 # spring months: mar,apr,may
  tempmm_summer = mean(tempmm[[6]],tempmm[[7]],tempmm[[8]])-273.15 # summer months: jun,jul,aug
  tempmm_autumn = mean(tempmm[[9]],tempmm[[10]],tempmm[[11]])-273.15 # autumn months: sep,oct,nov
  
  precmm = brick(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3a_past/",folder_model_past[i],"/pr_day_",folder_model_past[i],"_historical_gswp3-w5e5_",year_intervals[j],"_ymonmean.nc"))
  # mean per season and conversion to kg/m2/day
  precmm_winter = mean(precmm[[12]],precmm[[1]],precmm[[2]])*60*60*24 # winter months: dec,jan,feb
  precmm_spring = mean(precmm[[3]],precmm[[4]],precmm[[5]])*60*60*24 # spring months: mar,apr,may
  precmm_summer = mean(precmm[[6]],precmm[[7]],precmm[[8]])*60*60*24 # summer months: jun,jul,aug
  precmm_autumn = mean(precmm[[9]],precmm[[10]],precmm[[11]])*60*60*24 # autumn months: sep,oct,nov
  
  relhmm = brick(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3a_past/",folder_model_past[i],"/hurs_day_",folder_model_past[i],"_historical_gswp3-w5e5_",year_intervals[j],"_ymonmean.nc"))
  # mean per season
  relhmm_winter = mean(relhmm[[12]],relhmm[[1]],relhmm[[2]]) # winter months: dec,jan,feb
  relhmm_spring = mean(relhmm[[3]],relhmm[[4]],relhmm[[5]]) # spring months: mar,apr,may
  relhmm_summer = mean(relhmm[[6]],relhmm[[7]],relhmm[[8]]) # summer months: jun,jul,aug
  relhmm_autumn = mean(relhmm[[9]],relhmm[[10]],relhmm[[11]]) # autumn months: sep,oct,nov
  
  # population
  pop = raster(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3a_past/population_histsoc_0p5deg_annual_",year_intervals[j],"_timmean.nc4"),varname="total-population")
  
  if(year_intervals[j] == "2000_2019"){
    #land-cover
    land_cover = nc_open(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3a_past/landcover_annual_2000_2015_timmean.nc4"))
    
    landCoverVariableIDs = names(land_cover$var)
    landCoverVariableNames = as.character(read.csv("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/LC_vars.csv")[1:12,2])
    land_covers1 = list(); land_covers2 = list(); land_covers3 = list()
    for (p in 2:13) land_covers1[[p-1]] = brick(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3a_past/landcover_annual_2000_2015_timmean.nc4"), varname=landCoverVariableIDs[p])
    for (q in 1:length(land_covers1)) names(land_covers1[[q]]) = landCoverVariableNames[q]
  }else{
    land_cover = nc_open(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3a_past/landcover_annual_",year_intervals[j],"_timmean.nc4"))
    
    landCoverVariableIDs = names(land_cover$var)
    landCoverVariableNames = as.character(read.csv("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/LC_vars.csv")[1:12,2])
    land_covers1 = list(); land_covers2 = list(); land_covers3 = list()
    for (p in 2:13) land_covers1[[p-1]] = brick(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3a_past/landcover_annual_",year_intervals[j],"_timmean.nc4"), varname=landCoverVariableIDs[p])
    for (q in 1:length(land_covers1)) names(land_covers1[[q]]) = landCoverVariableNames[q]
  }
  
  variable_codes = c("croplands","pastures","urbanAreas","primaryForest","secondaryForest","rangelands")
  variable_names = c("crops","pasture","urban land","forested primary land",
                     "potentially forested secondary land","rangeland")
  for (r in 1:length(variable_names))
  {
    names = gsub("\\."," ",landCoverVariableNames); indices = which(landCoverVariableNames==variable_names[r])
    if (length(indices) == 0) indices = which(grepl(variable_names[r],names))
    land_cover = land_covers1[[indices[1]]]; names(land_cover) = variable_codes[r]
    if (length(indices) > 1)
    {
      for (s in 2:length(indices)) land_cover[] = land_cover[]+land_covers1[[indices[s]]][]
    }
    land_covers2[[r]] = land_cover[[1]]; land_covers3[[r]] = raster::aggregate(land_cover[[1]],2)
  }
  
  pLog = pop; pLog[] = log10(pLog[]+1);pop[]=pop[]
  
  pop = exact_extract(pLog, TBEV, fun="mean")
  
  tempwin = exact_extract(tempmm_winter, TBEV, fun="mean")
  tempspr = exact_extract(tempmm_spring, TBEV, fun="mean")
  tempsum = exact_extract(tempmm_summer, TBEV, fun="mean")
  tempaut = exact_extract(tempmm_autumn, TBEV, fun="mean")
  
  precwin = exact_extract(precmm_winter, TBEV, fun="mean")
  precspr = exact_extract(precmm_spring, TBEV, fun="mean")
  precsum = exact_extract(precmm_summer, TBEV, fun="mean")
  precaut = exact_extract(precmm_autumn, TBEV, fun="mean")
  
  relhwin = exact_extract(relhmm_winter, TBEV, fun="mean")
  relhspr = exact_extract(relhmm_spring, TBEV, fun="mean")
  relhsum = exact_extract(relhmm_summer, TBEV, fun="mean")
  relhaut = exact_extract(relhmm_autumn, TBEV, fun="mean")
  
  pfa = exact_extract(land_covers3[[4]], TBEV, fun="mean")# primary forest areas
  sfa = exact_extract(land_covers3[[5]], TBEV, fun="mean")# secondary forest areas
  crops = exact_extract(land_covers3[[1]], TBEV, fun="mean")# croplands (all categories)
  past = exact_extract(land_covers3[[2]], TBEV, fun="mean")# managed pasture + rangeland
  urb = exact_extract(land_covers3[[3]], TBEV, fun="mean")# urban areas
  range = exact_extract(land_covers3[[6]], TBEV, fun="mean")# rangelands
  
  newdata = as.data.frame(matrix(NA,nrow=length(pop),ncol=22))
  colnames(newdata) = c("longitude","latitude","ID","temperature_winter","temperature_spring","temperature_summer","temperature_autumn","precipitation_winter","precipitation_spring","precipitation_summer","precipitation_autumn","relative_humidity_winter","relative_humidity_spring","relative_humidity_summer","relative_humidity_autumn","croplands","pastures","urbanAreas","primaryForest","secondaryForest","rangelands","population")
  
  newdata$longitude = coordinates(TBEV)[,1]
  newdata$latitude = coordinates(TBEV)[,2]
  newdata$ID = TBEV@data$ID
  newdata$population = pop
  newdata$temperature_winter = tempwin
  newdata$temperature_spring = tempspr
  newdata$temperature_summer = tempsum
  newdata$temperature_autumn = tempaut
  newdata$precipitation_winter = precwin
  newdata$precipitation_spring = precspr
  newdata$precipitation_summer = precsum
  newdata$precipitation_autumn = precaut
  newdata$relative_humidity_winter = relhwin
  newdata$relative_humidity_spring = relhspr
  newdata$relative_humidity_summer = relhsum
  newdata$relative_humidity_autumn = relhaut
  newdata$primaryForest = pfa
  newdata$secondaryForest = sfa
  newdata$croplands = crops
  newdata$pastures = past
  newdata$urbanAreas = urb
  newdata$rangelands = range 

  
  nberOfReplicates = 100 #you have 100 BRT models
  prediction_tot = matrix(0, nrow=length(pop), ncol=nberOfReplicates)

  for(k in 1:nberOfReplicates){
    n.trees = brt_model_outputs_Sib[[k]]$gbm.call$best.trees; type = "response"; single.tree = FALSE
    object = brt_model_outputs_Sib[[k]]; prediction = predict.gbm(object, newdata, n.trees, type, single.tree)
    prediction_tot[,k] = prediction
  }
  key <- paste0("prediction_past_", folder_model_past[i], "_",year_intervals[j])
  prediction_past_Sib[[key]] <- prediction_tot
  key <- paste0("data_past_", folder_model_past[i], "_",year_intervals[j])
  data_past_Sib[[key]] <- newdata
  
  }
}

     
save.image(file = "/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Data_BRT_Sib.RData")




```



### Plot ecological suitability maps for each past 20 yeas period


```{r}

#take mean of the predictions
for (i in 1:length(prediction_past_Sib)){
  key <- names(prediction_past_Sib)[i]
  prediction_past_Sib_mean <- matrix(rowMeans(prediction_past_Sib[[key]]), nrow=length(pop), ncol=1)
  prediction_past_Sib[[key]] <- prediction_past_Sib_mean
}

time_title <- c("1901-1919", "1920-1939", "1940-1959", "1960-1979", "1980-1999", "2000-2019")

# Define the color palette
colourScale <- rev(colorRampPalette(brewer.pal(11, "RdBu"))(121)[11:121])


# Function to plot a single map
plot_map <- function(index, key, data) {
  cols <- colourScale[round(((data - global_min) / (global_max - global_min)) * 110) + 1]
  plot(contour, lwd = 0.2, border = "gray30", col = NA)  # Base contour
  plot(TBEV.projection, col = cols, border = NA, lwd = 0.1, add = TRUE)  # Add the data
}

# Start PNG device
png("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Ecological_suitability_maps/ecological_suitability_Sib_past.png", width = 9600, height = 1600, res = 200) # Adjust width and height to fit 2x6     width = 9600, height = 3200, res = 200)  # Adjust width and height to fit 2x6 layout

# Set up plotting layout
par(mfrow = c(2, 6),  # 2 rows, 6 columns layout
    oma = c(0, 0, 0.8, 0),  # Outer margins
    mar = c(0, 0, 2, 0) + 0.1,  # Reduce plot margins to fit better
    mgp = c(2, 1, 0),  # Margin line for title, axis labels, and axis line
    cex = 0.8)  # Reduce the size of text to fit better

# Loop to generate the plots
for (i in 1:12) {
  key <- names(prediction_past_Sib)[i]
  data <- prediction_past_Sib[[key]]
  plot_map(i, key, data)
  
  # Add "a" and "b" annotations
  if (i == 1) {
    text(x = par("usr")[1] + (par("usr")[2] - par("usr")[1]) * 0.05, y = par("usr")[4] - (par("usr")[4] - par("usr")[3]) * 0.1, labels = "a", cex = 3.5, col = "black", adj = 0,font=2)
  }
  if (i == 7) {
    text(x = par("usr")[1] + (par("usr")[2] - par("usr")[1]) * 0.05, y = par("usr")[4] - (par("usr")[4] - par("usr")[3]) * 0.1, labels = "b", cex = 3.5, col = "black", adj = 0,font=2)
  }
  
  # Add years between maps
  if (i <= 6) {
    title(main = time_title[i], cex.main = 3.5, col.main = "black")  
  }
}



```


version with only the two last maps
```{r}
# Start PNG device
png("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Ecological_suitability_maps/ecological_suitability_Sib_past2.png", width = 1600, height = 1600, res = 200) # Adjust width and height to fit 2x6     width = 9600, height = 3200, res = 200)  # Adjust width and height to fit 2x6 layout

# Set up plotting layout
par(mfrow = c(2, 1),  # 2 rows, 6 columns layout
    oma = c(0, 0, 0, 0),  # Outer margins
    mar = c(0, 0, 2, 0) + 0.1,  # Reduce plot margins to fit better
    mgp = c(0, 1, 0),  # Margin line for title, axis labels, and axis line
    cex = 0.8)  # Reduce the size of text to fit better

for (i in 1:length(prediction_past_Sib)) {  # Adjust the range as necessary
  if (i %in% c(6, 12)) {
    key <- names(prediction_past_Sib)[i]
    data <- prediction_past_Sib[[key]]
    plot_map(i, key, data)
  }

  
  # Add "a" and "b" annotations
  if (i == 6) {
    text(x = par("usr")[1] + (par("usr")[2] - par("usr")[1]) * 0.05, y = par("usr")[4] - (par("usr")[4] - par("usr")[3]) * 0.1, labels = "a", cex = 2.5, col = "black", adj = 0, font=2)
  }
  if (i == 12) {
    text(x = par("usr")[1] + (par("usr")[2] - par("usr")[1]) * 0.05, y = par("usr")[4] - (par("usr")[4] - par("usr")[3]) * 0.1, labels = "b", cex = 2.5, col = "black", adj = 0, font=2)
  }
  
  # Add years between maps
  if (i == 6) {
    title(main = time_title[i], cex.main = 1.5, col.main = "black")  
  }
}

visible_positions <- c(0.2,0.4,0.6,0.8)  # Specify the positions of the labels

rast <- raster(as.matrix(c(global_min, global_max)))
plot(rast, legend.only = TRUE, add = TRUE, col = colourScale, 
     legend.width = 0.5, legend.shrink = 2, 
     smallplot = c(0.9, 0.905, 0.3, 0.5), adj = 3, 
     axis.args = list(
       at = visible_positions, # Spécifiez les positions des étiquettes
       labels = round(visible_positions, 2), # Spécifiez les étiquettes correspondantes
       cex.axis = 1,      # Ajustez cette valeur pour la taille des chiffres
       lwd = 1,             # Largeur des lignes de l'axe
       col = "gray30", 
       lwd.tick = 1,      # Largeur des petits traits des graduations
       col.tick = "gray30", 
       tck = -1,          # Longueur des  petits traits des graduations
       col.axis = "gray30", 
       line = 0, 
       mgp = c(0, 1, 0)  # Position des axes et des étiquettes
     ), 
     alpha = 1, side = 3)

```
<div class="alert alert-info">
  <strong>Practice 1</strong> Run the BRT approach for ECDC dataset independently (do not forget selecting the best spatial cross-validation method): is adding Padi-web data a plus when analyzing the virus ecological suitability?
</div>

<div class="alert alert-info">
  <strong>Practice 2</strong> Run the BRT approach for ECDC dataset independently (do not forget selecting the best spatial cross-validation method): How the relative influence of each climatic variable changes? 
</div>

<div class="alert alert-info">
  <strong>Practice 3</strong> Edit the script to consider each climatic variable per season (i.e. winter, spring, summer and fall). How the environmental suitability map changes? Is the predictive performance better (AUC)? What are the relative influences and response curves of the new variables?   
</div>
```{r include=FALSE}
###FUTURE
data_future_Sib <- list()
prediction_future_Sib <- list()
year_future = c("2021_2040","2041_2060","2061_2080","2081_2100") 
scenarios=c("ssp126","ssp370","ssp585")
MODELS = c("CanESM5-2","MRI-ESM2-0","MPI-ESM1-2-HR","MIROC6","IPSL-CM6A-LR","GFDL-ESM4","EC-Earth3","CNRM-ESM2-1","CNRM-CM6-1","UKESM1-0-LL")
models = c("canesm5","mri-esm2-0","mpi-esm1-2-hr","miroc6","ipsl-cm6a-lr","gfdl-esm4","ec-earth3","cnrm-esm2-1","cnrm-cm6-1","ukesm1-0-ll")

for(i in 1:length(models)){
  for(j in 1:length(scenarios)){
    for(k in 1:length(year_future)){
     year_key <- year_future[k]
      scenario_key <- scenarios[j]
      model_key <- models[i]
      ### BRT ###
  
  # read environmental data
  # mean per season and conversion to Celsius
      tempmm = brick(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3b_future/",MODELS[i],"/tas_day_bias-adjusted_",scenarios[j],"_",models[i],"_",year_future[k],"_ymonmean.nc"))
      tempmm_winter = mean(tempmm[[12]],tempmm[[1]],tempmm[[2]])-273.15 # winter months: dec,jan,feb
      tempmm_spring = mean(tempmm[[3]],tempmm[[4]],tempmm[[5]])-273.15 # spring months: mar,apr,may
      tempmm_summer = mean(tempmm[[6]],tempmm[[7]],tempmm[[8]])-273.15 # summer months: jun,jul,aug
      tempmm_autumn = mean(tempmm[[9]],tempmm[[10]],tempmm[[11]])-273.15 # autumn months: sep,oct,nov
      
      # mean per season and conversion to kg/m2/day
      precmm = brick(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3b_future/",MODELS[i],"/pr_day_bias-adjusted_",scenarios[j],"_",models[i],"_",year_future[k],"_ymonmean.nc"))
      precmm_winter = mean(precmm[[12]],precmm[[1]],precmm[[2]])*60*60*24 # winter months: dec,jan,feb
      precmm_spring = mean(precmm[[3]],precmm[[4]],precmm[[5]])*60*60*24 # spring months: mar,apr,may
      precmm_summer = mean(precmm[[6]],precmm[[7]],precmm[[8]])*60*60*24 # summer months: jun,jul,aug
      precmm_autumn = mean(precmm[[9]],precmm[[10]],precmm[[11]])*60*60*24 # autumn months: sep,oct,nov
      
      # mean per season
      relhmm =  brick(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3b_future/",MODELS[i],"/hurs_day_bias-adjusted_",scenarios[j],"_",models[i],"_",year_future[k],"_ymonmean.nc"))
      relhmm_winter = mean(relhmm[[12]],relhmm[[1]],relhmm[[2]]) # winter months: dec,jan,feb
      relhmm_spring = mean(relhmm[[3]],relhmm[[4]],relhmm[[5]]) # spring months: mar,apr,may
      relhmm_summer = mean(relhmm[[6]],relhmm[[7]],relhmm[[8]]) # summer months: jun,jul,aug
      relhmm_autumn = mean(relhmm[[9]],relhmm[[10]],relhmm[[11]]) # autumn months: sep,oct,nov
      
      # population
      pop = raster(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3b_future/population_bias-adjustedsoc_0p5deg_annual_",year_future[k],"_timmean.nc4"),varname="number_of_people")
    
      #land-cover
      land_cover = nc_open(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3b_future/landcover_",scenarios[j],"_annual_",year_future[k],"_timmean.nc4"))
      
      landCoverVariableIDs = names(land_cover$var)
      landCoverVariableNames = as.character(read.csv("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/LC_vars.csv")[1:12,2])
      
      land_covers1 = list();land_covers2 = list();land_covers3 = list()
      for (p in 2:13) land_covers1[[p-1]] = brick(paste0("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/env_data/ISIMIP3b_future/landcover_",scenarios[j],"_annual_",year_future[k],"_timmean.nc4"), varname=landCoverVariableIDs[p])
      for (q in 1:length(land_covers1)) names(land_covers1[[q]]) = landCoverVariableNames[q]
       variable_codes = c("croplands","pastures","urbanAreas","primaryForest","secondaryForest","rangelands")
       variable_names = c("crops","pasture","urban land","forested primary land",
                     "potentially forested secondary land","rangeland")
      for (r in 1:length(variable_names))
      {
      names = gsub("\\."," ",landCoverVariableNames); indices = which(landCoverVariableNames==variable_names[r])
      if (length(indices) == 0) indices = which(grepl(variable_names[r],names))
      land_cover = land_covers1[[indices[1]]]; names(land_cover) = variable_codes[r]
      if (length(indices) > 1)
      {
        for (s in 2:length(indices)) land_cover[] = land_cover[]+land_covers1[[indices[s]]][]
      }
      land_covers2[[r]] = land_cover[[1]]; land_covers3[[r]] = raster::aggregate(land_cover[[1]],2)
      }
      
      pLog = pop; pLog[] = log10(pLog[]+1)
      pop = exact_extract(pLog, TBEV, fun="mean")
      
      tempwin = exact_extract(tempmm_winter, TBEV, fun="mean")
      tempspr = exact_extract(tempmm_spring, TBEV, fun="mean")
      tempsum = exact_extract(tempmm_summer, TBEV, fun="mean")
      tempaut = exact_extract(tempmm_autumn, TBEV, fun="mean")
      
      precwin = exact_extract(precmm_winter, TBEV, fun="mean")
      precspr = exact_extract(precmm_spring, TBEV, fun="mean")
      precsum = exact_extract(precmm_summer, TBEV, fun="mean")
      precaut = exact_extract(precmm_autumn, TBEV, fun="mean")
      
      relhwin = exact_extract(relhmm_winter, TBEV, fun="mean")
      relhspr = exact_extract(relhmm_spring, TBEV, fun="mean")
      relhsum = exact_extract(relhmm_summer, TBEV, fun="mean")
      relhaut = exact_extract(relhmm_autumn, TBEV, fun="mean")
      
      pfa = exact_extract(land_covers3[[4]], TBEV, fun="mean")# primary forest areas
      sfa = exact_extract(land_covers3[[5]], TBEV, fun="mean")# secondary forest areas
      crops = exact_extract(land_covers3[[1]], TBEV, fun="mean")# croplands (all categories)
      past = exact_extract(land_covers3[[2]], TBEV, fun="mean")# managed pasture + rangeland
      urb = exact_extract(land_covers3[[3]], TBEV, fun="mean")# urban areas
      range = exact_extract(land_covers3[[6]], TBEV, fun="mean")# rangelands
      
      
      newdata = as.data.frame(matrix(NA,nrow=length(pop),ncol=22))
      colnames(newdata) = c("longitude","latitude","ID","temperature_winter","temperature_spring","temperature_summer","temperature_autumn","precipitation_winter","precipitation_spring","precipitation_summer","precipitation_autumn","relative_humidity_winter","relative_humidity_spring","relative_humidity_summer","relative_humidity_autumn","croplands","pastures","urbanAreas","primaryForest","secondaryForest","rangelands","population")

      
      newdata$longitude = coordinates(TBEV)[,1]
      newdata$latitude = coordinates(TBEV)[,2]
      newdata$ID = TBEV@data$ID
      newdata$population = pop
      newdata$temperature_winter = tempwin
      newdata$temperature_spring = tempspr
      newdata$temperature_summer = tempsum
      newdata$temperature_autumn = tempaut
      newdata$precipitation_winter = precwin
      newdata$precipitation_spring = precspr
      newdata$precipitation_summer = precsum
      newdata$precipitation_autumn = precaut
      newdata$relative_humidity_winter = relhwin
      newdata$relative_humidity_spring = relhspr
      newdata$relative_humidity_summer = relhsum
      newdata$relative_humidity_autumn = relhaut
      newdata$primaryForest = pfa
      newdata$secondaryForest = sfa
      newdata$croplands = crops
      newdata$pastures = past
      newdata$urbanAreas = urb
      newdata$rangelands = range 
      
      nberOfReplicates = 100 #you have 100 BRT models
      prediction_tot = matrix(0, nrow=length(pop), ncol=nberOfReplicates)

      for(l in 1:nberOfReplicates){
        n.trees = brt_model_outputs_Sib[[l]]$gbm.call$best.trees; type = "response"; single.tree = FALSE
        object = brt_model_outputs_Sib[[l]]; prediction = predict.gbm(object, newdata, n.trees, type, single.tree)
        prediction_tot[,l] = prediction
      }
      prediction_tot = rowMeans(prediction_tot)
      key <- paste(scenario_key, year_key,  sep = "_")
      data_future_Sib[[key]][[model_key]] <- newdata
      prediction_future_Sib[[key]][[model_key]] <- prediction_tot
    }
  }
}

save.image("~/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Data_BRT_Sib.RData")
```


### Plot ecological suitability maps for each future 20 yeas period



```{r}
prediction_future_Sib_mean <- prediction_future_Sib
#take mean of the models predictions
for (key in names(prediction_future_Sib_mean)) {
  model_predictions <- prediction_future_Sib_mean[[key]]
  all_models_data <- do.call(cbind, model_predictions)  # Combinez toutes les prédictions des modèles en une matrice

  # Calculer la moyenne pour chaque ligne de la matrice
  mean_predictions <- rowMeans(all_models_data, na.rm = TRUE)
  
  # Stocker les moyennes dans une nouvelle liste avec la même clé
  prediction_future_Sib_mean[[key]] <- mean_predictions
}

# Définir la palette de coulSibs
colourScale = rev(colorRampPalette(brewer.pal(11,"RdBu"))(121)[11:121])

year_title_future = c("2021-040","2041-2060","2061-2080","2081-2100") 


# Start PNG device
png("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Ecological_suitability_maps/ecological_suitability_Sib_future.png", width = 6400, height = 2400, res = 200)  # 2400x2400 pixels at 300 PPI

# Set up plotting layout with reduced margins
par(mfrow = c(3, 4),  # Assuming you have 12 plots; adjust as needed
    oma = c(0, 0, 2, 0),  # Outer margins
    mar = c(0.5, 0.5, 2, 0.5),  # Reduce plot margins to fit better
    mgp = c(2, 1, 0),  # Margin line for title, axis labels, and axis line
    cex = 0.8)  # Reduce the size of text to fit better

# Loop to generate the plots
for (i in 1:12) {
  key <- names(prediction_future_Sib_mean)[i]
  data <- prediction_future_Sib_mean[[key]]
  plot_map(i, key, data)

  # Add "ssp" annotations at the top-left corner
  if (i == 1) {
    text(x = par("usr")[1] + (par("usr")[2] - par("usr")[1]) * 0.05, 
         y = par("usr")[4] - (par("usr")[4] - par("usr")[3]) * 0.05, 
         labels = "SSP1-2.6", cex = 2.2, col = "black", adj = 0, font=2)
  }
  if (i == 5) {
    text(x = par("usr")[1] + (par("usr")[2] - par("usr")[1]) * 0.05, 
         y = par("usr")[4] - (par("usr")[4] - par("usr")[3]) * 0.05, 
         labels = "SSP3-7.0", cex = 2.2, col = "black", adj = 0, font=2)
  }
  if (i == 9) {
    text(x = par("usr")[1] + (par("usr")[2] - par("usr")[1]) * 0.05, 
         y = par("usr")[4] - (par("usr")[4] - par("usr")[3]) * 0.05, 
         labels = "SSP5-8.5", cex = 2.2, col = "black", adj = 0, font=2)
  }
  
  # Add years just above the top maps
  if (i <= 4) {
    title(main = year_title_future[i], cex.main = 2.5, col.main = "black")  }
}


  



```



Future maps but with only first and last column
```{r}

year_title_future = c("2021-2040","2041-2060","2061-2080","2081-2100") 


# Start PNG device
png("/Users/loicgonzalez/Library/CloudStorage/OneDrive-UniversitéLibredeBruxelles/Bioingénieur/MA-2- 2023-2024/Mémoire/GitHub/Memoire/Données & script/Ecological_suitability_maps/ecological_suitability_Sib_future2.png", width = 3200, height = 2400, res = 200)  # 2400x2400 pixels at 300 PPI

# Set up plotting layout with reduced margins
par(mfrow = c(3, 2),  # Assuming you have 12 plots; adjust as needed
    oma = c(0, 0, 0, 0),  # Outer margins
    mar = c(0, 0, 2, 0),  # Reduce plot margins to fit better
    mgp = c(2, 1, 0),  # Margin line for title, axis labels, and axis line
    cex = 0.8)  # Reduce the size of text to fit better

# Loop to generate the plots
for (i in 1:length(prediction_future_Sib_mean)) {  # Adjust the range as necessary
  if (i %in% c(1,4,5,8,9,12)) {
    key <- names(prediction_future_Sib_mean)[i]
    data <- prediction_future_Sib_mean[[key]]
    plot_map(i, key, data)
  }

  # Add "ssp" annotations at the top-left corner
  if (i == 1) {
    text(x = par("usr")[1] + (par("usr")[2] - par("usr")[1]) * 0.05, 
         y = par("usr")[4] - (par("usr")[4] - par("usr")[3]) * 0.05, 
         labels = "SSP1-2.6", cex = 2, col = "black", adj = 0, font=2)
  }
  if (i == 5) {
    text(x = par("usr")[1] + (par("usr")[2] - par("usr")[1]) * 0.05, 
         y = par("usr")[4] - (par("usr")[4] - par("usr")[3]) * 0.05, 
         labels = "SSP3-7.0", cex = 2, col = "black", adj = 0, font=2)
  }
  if (i == 9) {
    text(x = par("usr")[1] + (par("usr")[2] - par("usr")[1]) * 0.05, 
         y = par("usr")[4] - (par("usr")[4] - par("usr")[3]) * 0.05, 
         labels = "SSP5-8.5", cex = 2, col = "black", adj = 0, font=2)
  }
  
  # Add years just above the top maps
  if (i %in% c(1,4)) {
    title(main = year_title_future[i], cex.main = 2, col.main = "black")  }
}

visible_positions <- c(0.2,0.4,0.6,0.8)  # Specify the positions of the labels

rast <- raster(as.matrix(c(global_min, global_max)))
plot(rast, legend.only = TRUE, add = TRUE, col = colourScale, 
     legend.width = 0.5, legend.shrink = 2, 
     smallplot = c(0.9, 0.91, 0.3, 0.5), adj = 3, 
     axis.args = list(
       at = visible_positions, # Spécifiez les positions des étiquettes
       labels = round(visible_positions, 2), # Spécifiez les étiquettes correspondantes
       cex.axis = 1.5,      # Ajustez cette valeur pour la taille des chiffres
       lwd = 1,             # Largeur des lignes de l'axe
       col = "gray30", 
       lwd.tick = 1,      # Largeur des petits traits des graduations
       col.tick = "gray30", 
       tck = -1,          # Longueur des  petits traits des graduations
       col.axis = "gray30", 
       line = 0, 
       mgp = c(0, 1, 0)  # Position des axes et des étiquettes
     ), 
     alpha = 1, side = 3)





```
















